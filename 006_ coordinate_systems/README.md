# Coordinate systems

![enter image description here](https://i.imgur.com/tmW1SKY.png)

**Model coordinates:**
**Local/model coordinates** are the coordinates of your object relative to its local origin; they're the coordinates your object begins in.
> Read more at 
> - [codinglabs matrix chain transformation article](http://www.codinglabs.net/article_world_view_projection_matrix.aspx)
> - [Solarian Programer blog explanation](https://solarianprogrammer.com/2013/05/22/opengl-101-matrices-projection-view-model/)

**Model matrix**
The next step is to transform the **local coordinates to world-space** coordinates which are coordinates in respect of a larger world. These coordinates are relative to a global origin of the world, together with many other objects also placed relative to the world's origin.

**View matrix**
Next we transform the world coordinates to **view-space** coordinates in such a way that each coordinate is as **seen from the camera or viewer's point of view**.

**Projection matrix**
After the coordinates are in view space we want to project them to clip coordinates. Clip coordinates are processed to the -1.0 and 1.0 range and determine which vertices will end up on the screen.
Note that as default opengl discards every vertex that is outside the NDC range, so is no necesary multiply them by the projection matrix for achieve this, however the projection matrix is considered the last vertex tranformation in a traditional vertex transformation pipeline and for this reason is possible to consider that the projection matrix determines which vertices will end up on the screen.
The true job of the projection matrix is to transform object vertices in a such way that rasterization stage can project vertices into the 2D surface known as viewport. but the result of the projection matrix is no a 2D vertex, this is a 3D vector (remember originally was a 4D vector).

> Read more at 
> - [Implementing transformation matrices tutorial by catlikecoding](http://catlikecoding.com/unity/tutorials/rendering/part-1/)
> - [In-depth explanation of projection matrices by scratchpixel 2.0](https://www.scratchapixel.com/lessons/3d-basic-rendering/perspective-and-orthographic-projection-matrix/projection-matrix-introduction)

# Utils

**Mesh:** High-level abstraction (could be a C++ class that interprets info and pass it from CPU to GPU using the graphic API) that describes 3d model vertex positions, EBO for index drawing and other useful vertex info as colors, normals, tangents, binormals, etc..

**About index ordering in EBO:** Which side a triangle is visible from is determined by the orientation of its vertex indices. By default, if they are arranged in a `clockwise direction` the triangle is considered to be `forward-facing` and visible. Counter-clockwise triangles are discarded so we don't need to spend time rendering the insides of objects, which are typically not meant to be seen anyway.

![enter image description here](https://i.imgur.com/VixPnZ6.png)

The previous concept is a particular theme of a more general concept known as **face culling**

**Face culling:** Triangle primitives after all transformation steps have a particular facing. This is defined by the order of the three vertices that make up the triangle, as well as their apparent order on-screen. Triangles can be discarded based on their apparent facing, a process known as Face Culling.

**---- Winding order**
The order of the vertices in a triangle, when combined with their visual orientation, can be used to determine whether the triangle is being seen from the "front" or the "back" side.

This is determined by the winding order of the triangle. Given an ordering of the triangle's three vertices, a triangle can appear to have a clockwise winding or counter-clockwise winding. Clockwise means that the three vertices, in order, rotate clockwise around the triangle's center. Counter-clockwise means that the three vertices, in order, rotate counter-clockwise around the triangle's center.

Which side is considered the "front" side is controlled by this function:

	void glFrontFace(GLenum mode​);

This is global state. mode​ may be `GL_CW` or `GL_CCW`, which mean clockwise or counter-clockwise is front, respectively. On a freshly created OpenGL Context, the default front face is `GL_CCW`.

The `Fragment Shader` gets a built-in input value saying whether the fragment was generated by the triangle's front face (this will always be true for non-triangular primitives).

![enter image description here](https://i.imgur.com/69FEojO.png)
[enter link description here](Read%20more%20in%20official%20docs)

**About tangent space:** Normal maps are defined in tangent space. This is a 3D space that flows around the surface of an object. This approach allows us to apply the same normal map in different places and orientations.

The surface normal represents upward in this space, but which way is right? That's defined by the tangent. Ideally, the angle between these two vectors is 90°. The cross product of them yields the third direction needed to define 3D space. In reality the angle is often not 90° but the results are still good enough.

So a tangent is a 3D vector, but Unity actually uses a 4D vector. Its fourth component is always either −1 or 1, which is used to control the direction of the third tangent space dimension – either forward or backward. This facilitates mirroring of normal maps, which is often used in 3D models of things with bilateral symmetry, like people. The way Unity's shaders perform this calculation requires us to use −1.